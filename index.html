<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Qubit Bloch Sphere Visualization</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- Include the Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script>
// Create the scene
const scene = new THREE.Scene();

// Set up the camera with a perspective view
const camera = new THREE.PerspectiveCamera(
    75, // Field of view
    window.innerWidth / window.innerHeight, // Aspect ratio
    0.1, // Near clipping plane
    1000 // Far clipping plane
);
camera.position.z = 5; // Position the camera along the z-axis

// Initialize the WebGL renderer
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight); // Set the size of the rendering window
document.body.appendChild(renderer.domElement); // Append the renderer to the DOM
// Define the geometry of the sphere with a radius of 1 and 32 segments for width and height
const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);

// Create a material with a semi-transparent white color
const sphereMaterial = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    opacity: 0.3,
    transparent: true,
    wireframe: true // Display the sphere as a wireframe
});

// Combine the geometry and material into a mesh
const blochSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
scene.add(blochSphere); // Add the sphere to the scene
// Function to create an axis line from start to end with a specified color
function createAxis(start, end, color) {
    const material = new THREE.LineBasicMaterial({ color: color });
    const points = [start, end];
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    return new THREE.Line(geometry, material);
}

// Add the x-axis in red
const xAxis = createAxis(
    new THREE.Vector3(-1.5, 0, 0), // Start point
    new THREE.Vector3(1.5, 0, 0), // End point
    0xff0000 // Red color
);
scene.add(xAxis);

// Add the y-axis in green
const yAxis = createAxis(
    new THREE.Vector3(0, -1.5, 0), // Start point
    new THREE.Vector3(0, 1.5, 0), // End point
    0x00ff00 // Green color
);
scene.add(yAxis);

// Add the z-axis in blue
const zAxis = createAxis(
    new THREE.Vector3(0, 0, -1.5), // Start point
    new THREE.Vector3(0, 0, 1.5), // End point
    0x0000ff // Blue color
);
scene.add(zAxis);
// Function to create an arrow representing the qubit state
function createQubitArrow() {
    const direction = new THREE.Vector3(0, 0, 1); // Default direction along the z-axis
    const length = 1; // Length of the arrow
    const color = 0xffff00; // Yellow color
    const arrowHelper = new THREE.ArrowHelper(direction, new THREE.Vector3(0, 0, 0), length, color);
    return arrowHelper;
}

const qubitArrow = createQubitArrow();
scene.add(qubitArrow); // Add the qubit arrow to the scene
// Function to update the qubit arrow's direction based on theta and phi angles
function updateQubitState(theta, phi) {
    // Convert spherical coordinates to Cartesian coordinates
    const x = Math.sin(theta) * Math.cos(phi);
    const y = Math.sin(theta) * Math.sin(phi);
    const z = Math.cos(theta);

    // Update the direction of the qubit arrow
    qubitArrow.setDirection(new THREE.Vector3(x, y, z).normalize());
}

// Example: Set the qubit state to |+> (theta = Ï€/2, phi = 0)
updateQubitState(Math.PI / 2, 0);
// Function to handle window resizing
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight; // Update camera aspect ratio
    camera.updateProjectionMatrix(); // Apply the changes to the camera
    renderer.setSize(window.innerWidth, window.innerHeight); // Update renderer size
}

// Add event listener for window resize
window.addEventListener('resize', onWindowResize, false);

// Animation loop to render the scene
function animate() {
    requestAnimationFrame(animate); // Request the next frame

    // Optional: Rotate the Bloch sphere for better visualization
    blochSphere.rotation.y += 0.01;

    renderer.render(scene, camera); // Render the scene from the perspective of the camera
}
animate(); // Start the animation loop

 

    </script>
</body>
</html>
